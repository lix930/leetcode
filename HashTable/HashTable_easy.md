## 136. Single Number

Given an array of integers, every element appears *twice* except for one. Find that single one.

**Note:**
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

第一眼看到这题目的解法： 用 HashMap 计数， 然后找出计数为1的数；

```java
    public int singleNumber(int[] nums) {
    Map<Integer, Integer> map = new HashMap<>();
    int index = 0;
    for(int i = 0; i < nums.length; i++){
        if(map.containsKey(nums[i]))
            map.put(nums[i], map.get(nums[i]) + 1);
        else
            map.put(nums[i], 1);
    }
    for(int i = 0; i < nums.length; i++){
        if(map.get(nums[i]) == 1)
            index = i;
    }
    return nums[index];
}
```
trick solutions

```java
public int singleNumber(int[] nums) {
        int res = 0;
        for(int num : nums) {
            res ^= num;   //使用 异或
        }
        return res;
    }
```

XOR 操作符 的特性

1. xor是可交换顺序的运算符 （i.e. `a xor b = b xor a`）
2. 一个数 异或 自己等于0 （i.e. `a xor a = 0`）
3. `0 xor a = a`

即    `a xor b xor a = a xor a xor b = 0 xor b = b.` 

`[1,4,1,4,5]` ->`1 xor 4 xor 1 xor 4 xor 5`  -> `1 xor 1 xor 4 xor 4 xor 5` -> `0 xor 0 oxr 5 `  -> `5`




## 389. Find the Difference
Given two strings **s** and **t** which consist of only lowercase letters.

String **t** is generated by random shuffling string **s** and then add one more letter at a random position.

Find the letter that was added in **t**.

**Example:**

```
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
```

solution: 使用XOR找出两个字符串中的不同

```java
public char findTheDifference(String s, String t) {
    char c = 0;
    for(int i = 0; i < s.length(); i++)
        c ^= s.charAt(i);
    for(int i = 0; i < t.length(); i++)
        c ^= t.charAt(i);
    return c;
    
}
```


## 149. Intersection of Two Arrays


Given two arrays, write a function to compute their intersection.

**Example:**
Given *nums1* = `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, return `[2]`.

**Note:**

- Each element in the result must be unique.
- The result can be in any order.

solution: 


```java
public int[] intersection(int[] nums1, int[] nums2) {    
    Set<Integer> set = new HashSet<Integer>();
    Set<Integer> resultSet = new HashSet<Integer>();
    
    for(int i = 0; i < nums1.length; i++)
        set.add(nums1[i]);
    for(int i = 0; i < nums2.length; i++)
        if(set.contains(nums2[i]))
            resultSet.add(nums2[i]);
            
    int[] result = new int[resultSet.size()];
    int index = 0;
    for(int i : resultSet)
        result[index++] = i;
    return result;
}
```
